import libmambapy.bindings.solver
import libmambapy.bindings.solver.libsolv
import libmambapy.bindings.specs
import libmambapy.bindings.utils
import os
from typing import Any, ClassVar, Iterable, Iterator, overload

MAMBA_CLEAN_ALL: int
MAMBA_CLEAN_INDEX: int
MAMBA_CLEAN_LOCKS: int
MAMBA_CLEAN_PKGS: int
MAMBA_CLEAN_TARBALLS: int
MAMBA_FORCE_REINSTALL: str
MAMBA_NO_DEPS: str
MAMBA_ONLY_DEPS: str
SOLVER_ALLOWUNINSTALL: str
SOLVER_CLEANDEPS: str
SOLVER_DISFAVOR: str
SOLVER_DISTUPGRADE: str
SOLVER_DROP_ORPHANED: str
SOLVER_ERASE: str
SOLVER_ESSENTIAL: str
SOLVER_FAVOR: str
SOLVER_FLAG_ADD_ALREADY_RECOMMENDED: str
SOLVER_FLAG_ALLOW_ARCHCHANGE: str
SOLVER_FLAG_ALLOW_DOWNGRADE: str
SOLVER_FLAG_ALLOW_NAMECHANGE: str
SOLVER_FLAG_ALLOW_UNINSTALL: str
SOLVER_FLAG_ALLOW_VENDORCHANGE: str
SOLVER_FLAG_BEST_OBEY_POLICY: str
SOLVER_FLAG_BREAK_ORPHANS: str
SOLVER_FLAG_DUP_ALLOW_ARCHCHANGE: str
SOLVER_FLAG_DUP_ALLOW_DOWNGRADE: str
SOLVER_FLAG_DUP_ALLOW_NAMECHANGE: str
SOLVER_FLAG_DUP_ALLOW_VENDORCHANGE: str
SOLVER_FLAG_FOCUS_BEST: str
SOLVER_FLAG_FOCUS_INSTALLED: str
SOLVER_FLAG_IGNORE_RECOMMENDED: str
SOLVER_FLAG_INSTALL_ALSO_UPDATES: str
SOLVER_FLAG_KEEP_EXPLICIT_OBSOLETES: str
SOLVER_FLAG_KEEP_ORPHANS: str
SOLVER_FLAG_NEED_UPDATEPROVIDE: str
SOLVER_FLAG_NO_AUTOTARGET: str
SOLVER_FLAG_NO_INFARCHCHECK: str
SOLVER_FLAG_NO_UPDATEPROVIDE: str
SOLVER_FLAG_ONLY_NAMESPACE_RECOMMENDED: str
SOLVER_FLAG_SPLITPROVIDES: str
SOLVER_FLAG_STRICT_REPO_PRIORITY: str
SOLVER_FLAG_STRONG_RECOMMENDS: str
SOLVER_FLAG_URPM_REORDER: str
SOLVER_FLAG_YUM_OBSOLETES: str
SOLVER_FORCEBEST: str
SOLVER_INSTALL: str
SOLVER_JOBMASK: str
SOLVER_LOCK: str
SOLVER_MULTIVERSION: str
SOLVER_NOAUTOSET: str
SOLVER_NOOP: str
SOLVER_NOTBYUSER: str
SOLVER_ORUPDATE: str
SOLVER_SELECTMASK: str
SOLVER_SETARCH: str
SOLVER_SETEV: str
SOLVER_SETEVR: str
SOLVER_SETMASK: str
SOLVER_SETNAME: str
SOLVER_SETREPO: str
SOLVER_SETVENDOR: str
SOLVER_SOLVABLE: str
SOLVER_SOLVABLE_ALL: str
SOLVER_SOLVABLE_NAME: str
SOLVER_SOLVABLE_ONE_OF: str
SOLVER_SOLVABLE_PROVIDES: str
SOLVER_SOLVABLE_REPO: str
SOLVER_TARGETED: str
SOLVER_UPDATE: str
SOLVER_USERINSTALLED: str
SOLVER_VERIFY: str
SOLVER_WEAK: str
SOLVER_WEAKENDEPS: str

class ChannelContext:
    def __init__(
        self,
        params: libmambapy.bindings.specs.ChannelResolveParams,
        has_zst: list[libmambapy.bindings.specs.Channel],
    ) -> None: ...
    def has_zst(self, arg0: libmambapy.bindings.specs.Channel) -> bool: ...
    @overload
    def make_channel(self, arg0: str) -> list[libmambapy.bindings.specs.Channel]: ...
    @overload
    def make_channel(
        self, arg0: libmambapy.bindings.specs.UnresolvedChannel
    ) -> list[libmambapy.bindings.specs.Channel]: ...
    @staticmethod
    def make_conda_compatible(arg0: Context) -> ChannelContext: ...
    @staticmethod
    def make_simple(arg0: Context) -> ChannelContext: ...
    def params(self) -> libmambapy.bindings.specs.ChannelResolveParams: ...

class ChannelPriority:
    __members__: ClassVar[dict] = ...  # read-only
    Disabled: ClassVar[ChannelPriority] = ...
    Flexible: ClassVar[ChannelPriority] = ...
    Strict: ClassVar[ChannelPriority] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Context:
    class OutputParams:
        json: bool
        quiet: bool
        verbosity: int
        def __init__(self) -> None: ...

    class PrefixParams:
        conda_prefix: os.PathLike
        root_prefix: os.PathLike
        target_prefix: os.PathLike
        def __init__(self) -> None: ...

    class ThreadsParams:
        download_threads: int
        extract_threads: int
        def __init__(self) -> None: ...

    class ValidationParams:
        extra_safety_checks: bool
        safety_checks: VerificationLevel
        trusted_channels: list[str]
        verify_artifacts: bool
        def __init__(self) -> None: ...

    RemoteFetchParams: ClassVar[type] = ...  # read-only
    add_pip_as_python_dependency: bool
    always_yes: bool
    channel_alias: str
    channel_priority: ChannelPriority
    channels: list[str]
    conda_prefix: os.PathLike
    connect_timeout_secs: float
    custom_channels: dict[str, str]
    custom_multichannels: dict[str, list[str]]
    default_channels: list[str]
    download_only: bool
    download_threads: int
    dry_run: bool
    envs_dirs: list[os.PathLike]
    experimental_repodata_parsing: bool
    experimental_sat_error_message: bool
    extra_safety_checks: bool
    extract_threads: int
    graphics_params: GraphicsParams
    json: bool
    local_repodata_ttl: int
    max_retries: int
    offline: bool
    output_params: Context.OutputParams
    pkgs_dirs: list[os.PathLike]
    platform: str
    prefix_params: Context.PrefixParams
    proxy_servers: dict[str, str]
    quiet: bool
    remote_fetch_params: RemoteFetchParams
    retry_backoff: int
    retry_timeout: int
    root_prefix: os.PathLike
    safety_checks: VerificationLevel
    show_anaconda_channel_warnings: bool
    solver_flags: libmambapy.bindings.solver.Request.Flags
    ssl_verify: str
    target_prefix: os.PathLike
    threads_params: Context.ThreadsParams
    trusted_channels: list[str]
    use_index_cache: bool
    use_lockfiles: bool
    use_only_tar_bz2: bool
    user_agent: str
    validation_params: Context.ValidationParams
    verbosity: int
    verify_artifacts: bool
    def __init__(self, options: ContextOptions = ...) -> None: ...
    def set_log_level(self, arg0: LogLevel) -> None: ...
    def set_verbosity(self, arg0: int) -> None: ...
    @staticmethod
    def use_default_signal_handler(arg0: bool) -> None: ...

class ContextOptions:
    enable_logging: bool
    enable_signal_handling: bool
    def __init__(self, enable_logging: bool = ..., enable_signal_handling: bool = ...) -> None: ...

class DownloadOptions:
    download_threads: int
    fail_fast: bool
    sort: bool
    verbose: bool
    def __init__(self) -> None: ...

class GraphicsParams:
    no_progress_bars: bool
    palette: Palette
    def __init__(self) -> None: ...

class History:
    def __init__(self, path: os.PathLike, channel_context: ChannelContext) -> None: ...
    def get_requested_specs_map(self) -> dict[str, libmambapy.bindings.specs.MatchSpec]: ...

class Key:
    keytype: str
    keyval: str
    scheme: str
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def from_ed25519(arg0: str) -> Key: ...
    @property
    def json_str(self) -> str: ...

class KeyMgr(RoleBase, RoleBaseExtension):
    def __init__(self, arg0: str, arg1: RoleFullKeys, arg2: SpecBase) -> None: ...

class LockFile:
    def __init__(self, arg0: os.PathLike) -> None: ...

class LogLevel:
    __members__: ClassVar[dict] = ...  # read-only
    CRITICAL: ClassVar[LogLevel] = ...
    DEBUG: ClassVar[LogLevel] = ...
    ERROR: ClassVar[LogLevel] = ...
    INFO: ClassVar[LogLevel] = ...
    OFF: ClassVar[LogLevel] = ...
    TRACE: ClassVar[LogLevel] = ...
    WARNING: ClassVar[LogLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MambaNativeException(Exception): ...

class MatchSpec:
    def __init__(self, *args, **kwargs) -> None: ...

class MirrorMap:
    def __init__(self) -> None: ...
    def has_mirrors(self, mirror_name: str) -> bool: ...
    def __contains__(self, arg0: str) -> bool: ...
    def __len__(self) -> int: ...

class MultiPackageCache:
    def __init__(self, context: Context, pkgs_dirs: list[os.PathLike]) -> None: ...
    def get_tarball_path(
        self, arg0: libmambapy.bindings.specs.PackageInfo, arg1: bool
    ) -> os.PathLike: ...
    @property
    def first_writable_path(self) -> os.PathLike: ...

class PackageInfo:
    def __init__(self, *args, **kwargs) -> None: ...

class Palette:
    addition: libmambapy.bindings.utils.TextStyle
    deletion: libmambapy.bindings.utils.TextStyle
    external: libmambapy.bindings.utils.TextStyle
    failure: libmambapy.bindings.utils.TextStyle
    ignored: libmambapy.bindings.utils.TextStyle
    progress_bar_downloaded: libmambapy.bindings.utils.TextStyle
    progress_bar_extracted: libmambapy.bindings.utils.TextStyle
    progress_bar_none: libmambapy.bindings.utils.TextStyle
    safe: libmambapy.bindings.utils.TextStyle
    shown: libmambapy.bindings.utils.TextStyle
    success: libmambapy.bindings.utils.TextStyle
    unsafe: libmambapy.bindings.utils.TextStyle
    user: libmambapy.bindings.utils.TextStyle
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def no_color() -> Palette: ...
    @staticmethod
    def terminal() -> Palette: ...

class Path:
    def __init__(self, arg0: str) -> None: ...

class PkgMgr(RoleBase, RoleBaseExtension):
    def __init__(self, arg0: str, arg1: RoleFullKeys, arg2: SpecBase) -> None: ...

class Pool:
    def __init__(self, *args, **kwargs) -> None: ...

class PrefixData:
    def __init__(self, path: os.PathLike, channel_context: ChannelContext) -> None: ...
    def add_packages(self, arg0: list[libmambapy.bindings.specs.PackageInfo]) -> None: ...
    @property
    def package_records(self) -> dict[str, libmambapy.bindings.specs.PackageInfo]: ...

class Query:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def depends(
        arg0: libmambapy.bindings.solver.libsolv.Database, arg1: str, arg2: bool
    ) -> QueryResult: ...
    @staticmethod
    def find(arg0: libmambapy.bindings.solver.libsolv.Database, arg1: list[str]) -> QueryResult: ...
    @staticmethod
    def whoneeds(
        arg0: libmambapy.bindings.solver.libsolv.Database, arg1: str, arg2: bool
    ) -> QueryResult: ...

class QueryResult:
    def __init__(self, *args, **kwargs) -> None: ...
    def groupby(self, arg0: str) -> QueryResult: ...
    def json(self) -> str: ...
    def pretty(self, show_all_builds: bool = ...) -> str: ...
    def reset(self) -> QueryResult: ...
    def sort(self, arg0: str) -> QueryResult: ...
    def table(self) -> str: ...
    def to_dict(self) -> object: ...
    def tree(self, arg0: GraphicsParams) -> str: ...
    @property
    def query(self) -> str: ...
    @property
    def type(self) -> QueryType: ...

class QueryResultFormat:
    __members__: ClassVar[dict] = ...  # read-only
    Json: ClassVar[QueryResultFormat] = ...
    Pretty: ClassVar[QueryResultFormat] = ...
    RecursiveTable: ClassVar[QueryResultFormat] = ...
    Table: ClassVar[QueryResultFormat] = ...
    Tree: ClassVar[QueryResultFormat] = ...
    __entries: ClassVar[dict] = ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class QueryType:
    __members__: ClassVar[dict] = ...  # read-only
    Depends: ClassVar[QueryType] = ...
    Search: ClassVar[QueryType] = ...
    WhoNeeds: ClassVar[QueryType] = ...
    __entries: ClassVar[dict] = ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @staticmethod
    def parse(arg0: str) -> QueryType: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RemoteFetchParams:
    connect_timeout_secs: float
    max_retries: int
    proxy_servers: dict[str, str]
    retry_backoff: int
    retry_timeout: int
    ssl_verify: str
    user_agent: str
    def __init__(self) -> None: ...

class Repo:
    def __init__(self, *args, **kwargs) -> None: ...

class RoleBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def all_keys(self) -> dict[str, RoleFullKeys]: ...
    @property
    def expired(self) -> bool: ...
    @property
    def expires(self) -> str: ...
    @property
    def file_ext(self) -> str: ...
    @property
    def spec_version(self) -> SpecBase: ...
    @property
    def type(self) -> str: ...
    @property
    def version(self) -> int: ...

class RoleBaseExtension:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def timestamp(self) -> str: ...

class RoleFullKeys:
    keys: dict[str, Key]
    threshold: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keys: dict[str, Key], threshold: int) -> None: ...

class RootImpl(RoleBase, RoleBaseExtension):
    def __init__(self, json_str: str) -> None: ...
    def create_key_mgr(self, json_str: str) -> KeyMgr: ...
    def update(self, json_str: str) -> RootRole: ...

class RootRole:
    def __init__(self, *args, **kwargs) -> None: ...

class Solver:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SolverRuleinfo:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SpecBase:
    def __init__(self, *args, **kwargs) -> None: ...

class SpecImpl(SpecBase):
    def __init__(self) -> None: ...

class SubdirData:
    def __init__(self, *args, **kwargs) -> None: ...
    def cache_path(self) -> str: ...
    def create_repo(
        self, context: Context, db: libmambapy.bindings.solver.libsolv.Database
    ) -> libmambapy.bindings.solver.libsolv.RepoInfo: ...
    def loaded(self) -> bool: ...
    def valid_json_cache(self) -> os.PathLike | None: ...
    def valid_solv_cache(self) -> os.PathLike | None: ...

class SubdirDownloadParams:
    offline: bool
    repodata_check_zst: bool
    def __init__(self, *args, **kwargs) -> None: ...

class SubdirIndex:
    def __init__(self) -> None: ...
    def create(
        self,
        context: Context,
        channel_context: ChannelContext,
        channel: libmambapy.bindings.specs.Channel,
        platform: str,
        full_url: str,
        caches: MultiPackageCache,
        repodata_fn: str,
        url: str,
    ) -> None: ...
    def download(self, arg0: Context) -> bool: ...
    def __getitem__(self, arg0: int) -> SubdirIndexEntry: ...
    def __iter__(self) -> Iterator[SubdirIndexEntry]: ...
    def __len__(self) -> int: ...

class SubdirIndexEntry:
    def __init__(self) -> None: ...
    @property
    def channel(self) -> libmambapy.bindings.specs.Channel: ...
    @property
    def platform(self) -> str: ...
    @property
    def subdir(self) -> SubdirData: ...
    @property
    def url(self) -> str: ...

class SubdirIndexLoader:
    def __init__(self, *args, **kwargs) -> None: ...
    def caching_is_forbidden(self) -> bool: ...
    def channel(self) -> libmambapy.bindings.specs.Channel: ...
    def channel_id(self) -> str: ...
    def clear_valid_cache_files(self) -> None: ...
    @staticmethod
    def create(
        params: SubdirParams,
        channel: libmambapy.bindings.specs.Channel,
        platform: str,
        caches: MultiPackageCache,
        repodata_filename: str = ...,
    ) -> SubdirIndexLoader: ...
    @staticmethod
    def download_required_indexes(
        subdir_indices: Iterable,
        subdir_params: SubdirDownloadParams,
        auth_info: libmambapy.bindings.specs.AuthenticationDataBase,
        mirrors: MirrorMap,
        download_options: DownloadOptions,
        remote_fetch_params: RemoteFetchParams,
    ) -> None: ...
    def is_local(self) -> bool: ...
    def is_noarch(self) -> bool: ...
    def metadata(self) -> SubdirMetadata: ...
    def name(self) -> str: ...
    def platform(self) -> str: ...
    def repodata_url(self) -> libmambapy.bindings.specs.CondaURL: ...
    def valid_cache_found(self) -> bool: ...
    def valid_json_cache_path(self) -> os.PathLike: ...
    def valid_libsolv_cache_path(self) -> os.PathLike: ...
    def writable_libsolv_cache_path(self) -> os.PathLike: ...

class SubdirMetadata:
    class HttpMetadata:
        cache_control: str
        etag: str
        last_modified: str
        url: str
        def __init__(self, *args, **kwargs) -> None: ...

    def __init__(self, *args, **kwargs) -> None: ...
    def cache_control(self) -> str: ...
    def etag(self) -> str: ...
    def has_up_to_date_zst(self) -> bool: ...
    def is_valid_metadata(self, arg0: os.PathLike) -> bool: ...
    def last_modified(self) -> str: ...
    @staticmethod
    def read(arg0: os.PathLike) -> SubdirMetadata: ...
    @staticmethod
    def read_from_repodata_json(arg0: os.PathLike) -> SubdirMetadata: ...
    @staticmethod
    def read_state_file(arg0: os.PathLike, arg1: os.PathLike) -> SubdirMetadata: ...
    def set_http_metadata(self, arg0: SubdirMetadata.HttpMetadata) -> None: ...
    def set_zst(self, arg0: bool) -> None: ...
    def store_file_metadata(self, arg0: os.PathLike) -> None: ...
    def url(self) -> str: ...
    def write_state_file(self, arg0: os.PathLike) -> None: ...

class SubdirParams:
    local_repodata_ttl_s: int | None
    offline: bool
    repodata_force_use_zst: bool
    def __init__(self, *args, **kwargs) -> None: ...

class TimeRef:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def set(self, arg0: int) -> None: ...
    def set_now(self) -> None: ...
    def timestamp(self) -> str: ...

class Transaction:
    def __init__(
        self,
        arg0: Context,
        arg1: libmambapy.bindings.solver.libsolv.Database,
        arg2: libmambapy.bindings.solver.Request,
        arg3: libmambapy.bindings.solver.Solution,
        arg4: MultiPackageCache,
    ) -> None: ...
    def execute(self, arg0: Context, arg1: ChannelContext, arg2: PrefixData) -> bool: ...
    def fetch_extract_packages(self, arg0: Context, arg1: ChannelContext) -> bool: ...
    def log_json(self) -> None: ...
    def print(self, arg0: Context, arg1: ChannelContext) -> None: ...
    def prompt(self, arg0: Context, arg1: ChannelContext) -> bool: ...
    def to_conda(
        self,
    ) -> tuple[tuple[list[str], list[str]], list[tuple[str, str, str]], list[tuple[str, str]]]: ...

class VerificationLevel:
    __members__: ClassVar[dict] = ...  # read-only
    Disabled: ClassVar[VerificationLevel] = ...
    Enabled: ClassVar[VerificationLevel] = ...
    Warn: ClassVar[VerificationLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ostream_redirect:
    def __init__(self, stdout: bool = ..., stderr: bool = ...) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...

def cache_filename_from_url(arg0: str) -> str: ...
def cache_fn_url(arg0: str) -> str: ...
def cache_name_from_url(arg0: str) -> str: ...
def cancel_json_output(arg0: Context) -> None: ...
def clean(context: Context, flags: int) -> None: ...
def create_cache_dir(arg0: os.PathLike) -> str: ...
def extract_package(arg0: os.PathLike, arg1: os.PathLike, arg2: bool) -> None: ...
def generate_ed25519_keypair() -> tuple[str, str]: ...
def get_virtual_packages(arg0: Context) -> list[libmambapy.bindings.specs.PackageInfo]: ...
def init_console() -> None: ...
def load_installed_packages_in_database(
    context: Context, database: libmambapy.bindings.solver.libsolv.Database, prefix_data: PrefixData
) -> libmambapy.bindings.solver.libsolv.RepoInfo: ...
def load_subdir_in_database(
    context: Context,
    database: libmambapy.bindings.solver.libsolv.Database,
    subdir: SubdirIndexLoader,
) -> libmambapy.bindings.solver.libsolv.RepoInfo: ...
def sign(data: str, secret_key: str) -> str: ...
def transmute(
    context: Context,
    source_package: os.PathLike,
    destination_package: os.PathLike,
    compression_level: int,
    compression_threads: int = ...,
) -> bool: ...
