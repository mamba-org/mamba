import os
from _typeshed import Incomplete
from typing import ClassVar, Iterable, Iterator, overload

class AuthenticationDataBase:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: dict) -> None: ...
    def at_weaken(self, arg0: str) -> BasicHTTPAuthentication | BearerToken | CondaToken: ...
    def contains_weaken(self, arg0: str) -> bool: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: AuthenticationDataBase) -> bool: ...
    def __getitem__(self, arg0: str) -> BasicHTTPAuthentication | BearerToken | CondaToken: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: AuthenticationDataBase) -> bool: ...
    def __setitem__(
        self, arg0: str, arg1: BasicHTTPAuthentication | BearerToken | CondaToken
    ) -> None: ...

class BasicHTTPAuthentication:
    password: str
    user: str
    def __init__(self, user: str, password: str) -> None: ...
    def __copy__(self) -> BasicHTTPAuthentication: ...
    def __deepcopy__(self, memo: dict) -> BasicHTTPAuthentication: ...
    def __eq__(self, arg0: BasicHTTPAuthentication) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: BasicHTTPAuthentication) -> bool: ...

class BearerToken:
    token: str
    def __init__(self, token: str) -> None: ...
    def __copy__(self) -> BearerToken: ...
    def __deepcopy__(self, memo: dict) -> BearerToken: ...
    def __eq__(self, arg0: BearerToken) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: BearerToken) -> bool: ...

class Channel:
    class Match:
        __members__: ClassVar[dict] = ...  # read-only
        Full: ClassVar[Channel.Match] = ...
        InOtherPlatform: ClassVar[Channel.Match] = ...
        No: ClassVar[Channel.Match] = ...
        __entries: ClassVar[dict] = ...
        @overload
        def __init__(self, value: int) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    ChannelMap: ClassVar[type] = ...  # read-only
    MultiChannelMap: ClassVar[type] = ...  # read-only
    display_name: str
    platforms: set[str]
    url: CondaURL
    def __init__(self, url: CondaURL, display_name: str, platforms: set[str]) -> None: ...
    def contains_equivalent(self, arg0: Channel) -> bool: ...
    def contains_package(self, arg0: CondaURL) -> Channel.Match: ...
    def is_equivalent_to(self, arg0: Channel) -> bool: ...
    def is_package(self) -> bool: ...
    def platform_url(self, arg0: str) -> CondaURL: ...
    def platform_urls(self) -> list[CondaURL]: ...
    @overload
    @staticmethod
    def resolve(what: UnresolvedChannel, params: ChannelResolveParams) -> list[Channel]: ...
    @overload
    @staticmethod
    def resolve(
        what: UnresolvedChannel,
        platforms: set[str] = ...,
        channel_alias: CondaURL = ...,
        custom_channels: ChannelResolveParams.ChannelMap = ...,
        custom_multichannels: ChannelResolveParams.MultiChannelMap = ...,
        authentication_db: AuthenticationDataBase = ...,
        home_dir: str = ...,
        current_working_dir: str = ...,
    ) -> list[Channel]: ...
    def url_equivalent_with(self, arg0: Channel) -> bool: ...
    def __copy__(self) -> Channel: ...
    def __deepcopy__(self, memo: dict) -> Channel: ...
    def __eq__(self, arg0: Channel) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Channel) -> bool: ...

class ChannelResolveParams:
    class ChannelMap:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: dict) -> None: ...
        def at_weaken(self, arg0: str) -> Channel: ...
        def contains_weaken(self, arg0: str) -> bool: ...
        def items(self) -> ItemsView: ...
        def keys(self) -> KeysView: ...
        def values(self) -> ValuesView: ...
        def __bool__(self) -> bool: ...
        @overload
        def __contains__(self, arg0: str) -> bool: ...
        @overload
        def __contains__(self, arg0: object) -> bool: ...
        def __delitem__(self, arg0: str) -> None: ...
        def __eq__(self, arg0: ChannelResolveParams.ChannelMap) -> bool: ...
        def __getitem__(self, arg0: str) -> Channel: ...
        def __iter__(self) -> Iterator[str]: ...
        def __len__(self) -> int: ...
        def __ne__(self, arg0: ChannelResolveParams.ChannelMap) -> bool: ...
        def __setitem__(self, arg0: str, arg1: Channel) -> None: ...

    class MultiChannelMap:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: dict) -> None: ...
        def at_weaken(self, arg0: str) -> list[Channel]: ...
        def contains_weaken(self, arg0: str) -> bool: ...
        def items(self) -> ItemsView: ...
        def keys(self) -> KeysView: ...
        def values(self) -> ValuesView: ...
        def __bool__(self) -> bool: ...
        @overload
        def __contains__(self, arg0: str) -> bool: ...
        @overload
        def __contains__(self, arg0: object) -> bool: ...
        def __delitem__(self, arg0: str) -> None: ...
        def __eq__(self, arg0: ChannelResolveParams.MultiChannelMap) -> bool: ...
        def __getitem__(self, arg0: str) -> list[Channel]: ...
        def __iter__(self) -> Iterator[str]: ...
        def __len__(self) -> int: ...
        def __ne__(self, arg0: ChannelResolveParams.MultiChannelMap) -> bool: ...
        def __setitem__(self, arg0: str, arg1: list[Channel]) -> None: ...

    authentication_db: AuthenticationDataBase
    channel_alias: CondaURL
    current_working_dir: str
    custom_channels: ChannelResolveParams.ChannelMap
    custom_multichannels: ChannelResolveParams.MultiChannelMap
    home_dir: str
    platforms: set[str]
    def __init__(
        self,
        platforms: set[str] = ...,
        channel_alias: CondaURL = ...,
        custom_channels: ChannelResolveParams.ChannelMap = ...,
        custom_multichannels: ChannelResolveParams.MultiChannelMap = ...,
        authentication_db: AuthenticationDataBase = ...,
        home_dir: str = ...,
        current_working_dir: str = ...,
    ) -> None: ...
    def __copy__(self) -> BasicHTTPAuthentication: ...
    def __deepcopy__(self, memo: dict) -> BasicHTTPAuthentication: ...

class ChimeraStringSpec:
    def __init__(self) -> None: ...
    def contains(self, arg0: str) -> bool: ...
    def is_exact(self) -> bool: ...
    def is_explicitly_free(self) -> bool: ...
    def is_glob(self) -> bool: ...
    @staticmethod
    def parse(arg0: str) -> ChimeraStringSpec: ...
    def __copy__(self) -> ChimeraStringSpec: ...
    def __deepcopy__(self, memo: dict) -> ChimeraStringSpec: ...

class CommonVersion:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: CommonVersion) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: VersionPart) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: VersionPart) -> int: ...
    @overload
    def extend(self, L: CommonVersion) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: VersionPart) -> None: ...
    @overload
    def pop(self) -> VersionPart: ...
    @overload
    def pop(self, i: int) -> VersionPart: ...
    def remove(self, x: VersionPart) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: VersionPart) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    def __eq__(self, arg0: CommonVersion) -> bool: ...
    @overload
    def __getitem__(self, s: slice) -> CommonVersion: ...
    @overload
    def __getitem__(self, arg0: int) -> VersionPart: ...
    def __iter__(self) -> Iterator[VersionPart]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: CommonVersion) -> bool: ...
    @overload
    def __setitem__(self, arg0: int, arg1: VersionPart) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: CommonVersion) -> None: ...

class CondaToken:
    token: str
    def __init__(self, token: str) -> None: ...
    def __copy__(self) -> CondaToken: ...
    def __deepcopy__(self, memo: dict) -> CondaToken: ...
    def __eq__(self, arg0: CondaToken) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: CondaToken) -> bool: ...

class CondaURL:
    class Credentials:
        __members__: ClassVar[dict] = ...  # read-only
        Hide: ClassVar[CondaURL.Credentials] = ...
        Remove: ClassVar[CondaURL.Credentials] = ...
        Show: ClassVar[CondaURL.Credentials] = ...
        __entries: ClassVar[dict] = ...
        @overload
        def __init__(self, value: int) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    def __init__(self) -> None: ...
    def append_path(self, path: str, encode: bool = ...) -> None: ...
    def authentication(self) -> str: ...
    def authority(self) -> str: ...
    def clear_host(self) -> str: ...
    def clear_package(self) -> bool: ...
    def clear_password(self) -> str: ...
    def clear_path(self) -> str: ...
    def clear_path_without_token(self) -> bool: ...
    def clear_platform(self) -> bool: ...
    def clear_port(self) -> str: ...
    def clear_scheme(self) -> str: ...
    def clear_token(self) -> bool: ...
    def clear_user(self) -> str: ...
    def has_password(self) -> bool: ...
    def has_token(self) -> bool: ...
    def has_user(self) -> bool: ...
    def host(self, decode: bool = ...) -> str: ...
    def host_is_defaulted(self) -> bool: ...
    def package(self, decode: bool = ...) -> str: ...
    @staticmethod
    def parse(arg0: str) -> CondaURL: ...
    def password(self, decode: bool = ...) -> str: ...
    def path(self, decode: bool = ...) -> str: ...
    def path_without_token(self, decode: bool = ...) -> str: ...
    def platform(self) -> KnownPlatform | None: ...
    def port(self) -> str: ...
    def pretty_path(self) -> str: ...
    def pretty_str(
        self,
        strip_scheme: bool = ...,
        rstrip_path: str = ...,
        credentials: CondaURL.Credentials = ...,
    ) -> str: ...
    def scheme(self) -> str: ...
    def scheme_is_defaulted(self) -> bool: ...
    def set_host(self, host: str, encode: bool = ...) -> None: ...
    def set_package(self, package: str, encode: bool = ...) -> None: ...
    def set_password(self, password: str, encode: bool = ...) -> None: ...
    def set_path(self, path: str, encode: bool = ...) -> None: ...
    def set_path_without_token(self, path_without_token: str, encode: bool = ...) -> None: ...
    def set_platform(self, arg0: KnownPlatform) -> None: ...
    def set_port(self, arg0: str) -> None: ...
    def set_scheme(self, arg0: str) -> None: ...
    def set_token(self, arg0: str) -> None: ...
    def set_user(self, user: str, encode: bool = ...) -> None: ...
    def str(self, credentials: CondaURL.Credentials = ...) -> str: ...
    def token(self) -> str: ...
    def user(self, decode: bool = ...) -> str: ...
    def __copy__(self) -> CondaURL: ...
    def __deepcopy__(self, memo: dict) -> CondaURL: ...
    def __eq__(self, arg0: CondaURL) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: CondaURL) -> bool: ...
    def __truediv__(self, arg0: str) -> CondaURL: ...

class GlobSpec:
    free_pattern: ClassVar[str] = ...  # read-only
    glob_pattern: ClassVar[str] = ...  # read-only
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, spec: str) -> None: ...
    def contains(self, arg0: str) -> bool: ...
    def is_exact(self) -> bool: ...
    def is_free(self) -> bool: ...
    def __copy__(self) -> GlobSpec: ...
    def __deepcopy__(self, memo: dict) -> GlobSpec: ...

class ItemsView:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class KeysView:
    def __init__(self, *args, **kwargs) -> None: ...
    def __contains__(self, arg0: object) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class KnownPlatform:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    linux_32: ClassVar[KnownPlatform] = ...
    linux_64: ClassVar[KnownPlatform] = ...
    linux_aarch64: ClassVar[KnownPlatform] = ...
    linux_armv6l: ClassVar[KnownPlatform] = ...
    linux_armv7l: ClassVar[KnownPlatform] = ...
    linux_ppc64: ClassVar[KnownPlatform] = ...
    linux_ppc64le: ClassVar[KnownPlatform] = ...
    linux_riscv32: ClassVar[KnownPlatform] = ...
    linux_riscv64: ClassVar[KnownPlatform] = ...
    linux_s390x: ClassVar[KnownPlatform] = ...
    noarch: ClassVar[KnownPlatform] = ...
    osx_64: ClassVar[KnownPlatform] = ...
    osx_arm64: ClassVar[KnownPlatform] = ...
    win_32: ClassVar[KnownPlatform] = ...
    win_64: ClassVar[KnownPlatform] = ...
    win_arm64: ClassVar[KnownPlatform] = ...
    zos_z: ClassVar[KnownPlatform] = ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @staticmethod
    def build_platform() -> KnownPlatform: ...
    @staticmethod
    def count() -> int: ...
    @staticmethod
    def parse(arg0: str) -> KnownPlatform | None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MatchSpec:
    BuildStringSpec: ClassVar[type] = ...  # read-only
    NameSpec: ClassVar[type] = ...  # read-only
    alt_list_close: ClassVar[str] = ...  # read-only
    alt_list_open: ClassVar[str] = ...  # read-only
    alt_quote: ClassVar[str] = ...  # read-only
    attribute_assign: ClassVar[str] = ...  # read-only
    attribute_sep: ClassVar[str] = ...  # read-only
    channel_namespace_spec_sep: ClassVar[str] = ...  # read-only
    package_version_sep: ClassVar[list] = ...  # read-only
    preferred_list_close: ClassVar[str] = ...  # read-only
    preferred_list_open: ClassVar[str] = ...  # read-only
    preferred_quote: ClassVar[str] = ...  # read-only
    url_md5_sep: ClassVar[str] = ...  # read-only
    build_number: Incomplete
    build_string: ChimeraStringSpec
    channel: UnresolvedChannel | None
    features: str
    filename: str
    license: str
    license_family: str
    md5: str
    name: GlobSpec
    name_space: str
    optional: bool
    platforms: set[str] | None
    sha256: str
    track_features: set[str] | None
    version: VersionSpec
    def __init__(self, spec: str) -> None: ...
    def conda_build_form(self) -> str: ...
    @overload
    def contains_except_channel(self, arg0: PackageInfo) -> bool: ...
    @overload
    def contains_except_channel(
        self,
        name: str = ...,
        version: Version = ...,
        build_string: str = ...,
        build_number: int = ...,
        md5: str = ...,
        sha256: str = ...,
        license: str = ...,
        platform: str = ...,
        track_features: set[str] = ...,
    ) -> bool: ...
    def is_file(self) -> bool: ...
    def is_only_package_name(self) -> bool: ...
    def is_simple(self) -> bool: ...
    @staticmethod
    def parse(arg0: str) -> MatchSpec: ...
    @staticmethod
    def parse_url(arg0: str) -> MatchSpec: ...
    def __copy__(self) -> MatchSpec: ...
    def __deepcopy__(self, memo: dict) -> MatchSpec: ...

class NoArchType:
    __members__: ClassVar[dict] = ...  # read-only
    Generic: ClassVar[NoArchType] = ...
    No: ClassVar[NoArchType] = ...
    Python: ClassVar[NoArchType] = ...
    __entries: ClassVar[dict] = ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @staticmethod
    def count() -> int: ...
    @staticmethod
    def parse(arg0: str) -> NoArchType | None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PackageInfo:
    build_number: int
    build_string: str
    channel: str
    constrains: list[str]
    defaulted_keys: list[str]
    dependencies: list[str]
    filename: str
    fn: None
    license: str
    md5: str
    name: str
    noarch: NoArchType
    package_url: str
    platform: str
    sha256: str
    signatures: str
    size: int
    timestamp: int
    track_features: list[str]
    url: None
    version: str
    def __init__(
        self,
        name: str = ...,
        version: str = ...,
        build_string: str = ...,
        build_number: int = ...,
        channel: str = ...,
        package_url: str = ...,
        platform: str = ...,
        filename: str = ...,
        license: str = ...,
        md5: str = ...,
        sha256: str = ...,
        signatures: str = ...,
        track_features: list[str] = ...,
        depends: list[str] = ...,
        constrains: list[str] = ...,
        defaulted_keys: list[str] = ...,
        noarch: NoArchType = ...,
        size: int = ...,
        timestamp: int = ...,
    ) -> None: ...
    @staticmethod
    def from_url(arg0: str) -> PackageInfo: ...
    def __copy__(self) -> PackageInfo: ...
    def __deepcopy__(self, memo: dict) -> PackageInfo: ...
    def __eq__(self, arg0: PackageInfo) -> bool: ...
    def __ne__(self, arg0: PackageInfo) -> bool: ...

class ParseError(ValueError): ...

class RegexSpec:
    free_pattern: ClassVar[str] = ...  # read-only
    pattern_end: ClassVar[str] = ...  # read-only
    pattern_start: ClassVar[str] = ...  # read-only
    def __init__(self) -> None: ...
    def contains(self, arg0: str) -> bool: ...
    def is_exact(self) -> bool: ...
    def is_explicitly_free(self) -> bool: ...
    @staticmethod
    def parse(arg0: str) -> RegexSpec: ...
    def __copy__(self) -> RegexSpec: ...
    def __deepcopy__(self, memo: dict) -> RegexSpec: ...

class UnresolvedChannel:
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        Name: ClassVar[UnresolvedChannel.Type] = ...
        PackagePath: ClassVar[UnresolvedChannel.Type] = ...
        PackageURL: ClassVar[UnresolvedChannel.Type] = ...
        Path: ClassVar[UnresolvedChannel.Type] = ...
        URL: ClassVar[UnresolvedChannel.Type] = ...
        Unknown: ClassVar[UnresolvedChannel.Type] = ...
        __entries: ClassVar[dict] = ...
        @overload
        def __init__(self, value: int) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    def __init__(
        self, location: str, platform_filters: set[str], type: UnresolvedChannel.Type = ...
    ) -> None: ...
    @staticmethod
    def parse(arg0: str) -> UnresolvedChannel: ...
    def __copy__(self) -> UnresolvedChannel: ...
    def __deepcopy__(self, memo: dict) -> UnresolvedChannel: ...
    @property
    def location(self) -> str: ...
    @property
    def platform_filters(self) -> set[str]: ...
    @property
    def type(self) -> UnresolvedChannel.Type: ...

class ValuesView:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class Version:
    epoch_delim: ClassVar[str] = ...  # read-only
    local_delim: ClassVar[str] = ...  # read-only
    part_delim: ClassVar[str] = ...  # read-only
    part_delim_alt: ClassVar[str] = ...  # read-only
    part_delim_special: ClassVar[str] = ...  # read-only
    def __init__(self, epoch: int = ..., version=..., local=...) -> None: ...
    def compatible_with(self, older: Version, level: int) -> bool: ...
    @staticmethod
    def parse(str: str) -> Version: ...
    def starts_with(self, prefix: Version) -> bool: ...
    @overload
    def str(self) -> str: ...
    @overload
    def str(self, level: int) -> str: ...
    def __copy__(self) -> Version: ...
    def __deepcopy__(self, memo: dict) -> Version: ...
    def __eq__(self, arg0: Version) -> bool: ...
    def __ge__(self, arg0: Version) -> bool: ...
    def __gt__(self, arg0: Version) -> bool: ...
    def __le__(self, arg0: Version) -> bool: ...
    def __lt__(self, arg0: Version) -> bool: ...
    def __ne__(self, arg0: Version) -> bool: ...
    @property
    def epoch(self) -> int: ...
    @property
    def local(self) -> CommonVersion: ...
    @property
    def version(self) -> CommonVersion: ...

class VersionPart:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VersionPart) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: VersionPartAtom) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: VersionPartAtom) -> int: ...
    @overload
    def extend(self, L: VersionPart) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: VersionPartAtom) -> None: ...
    @overload
    def pop(self) -> VersionPartAtom: ...
    @overload
    def pop(self, i: int) -> VersionPartAtom: ...
    def remove(self, x: VersionPartAtom) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: VersionPartAtom) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    def __eq__(self, arg0: VersionPart) -> bool: ...
    @overload
    def __getitem__(self, s: slice) -> VersionPart: ...
    @overload
    def __getitem__(self, arg0: int) -> VersionPartAtom: ...
    def __iter__(self) -> Iterator[VersionPartAtom]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: VersionPart) -> bool: ...
    @overload
    def __setitem__(self, arg0: int, arg1: VersionPartAtom) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VersionPart) -> None: ...

class VersionPartAtom:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, numeral: int, literal: str = ...) -> None: ...
    def __copy__(self) -> VersionPartAtom: ...
    def __deepcopy__(self, memo: dict) -> VersionPartAtom: ...
    def __eq__(self, arg0: VersionPartAtom) -> bool: ...
    def __ge__(self, arg0: VersionPartAtom) -> bool: ...
    def __gt__(self, arg0: VersionPartAtom) -> bool: ...
    def __le__(self, arg0: VersionPartAtom) -> bool: ...
    def __lt__(self, arg0: VersionPartAtom) -> bool: ...
    def __ne__(self, arg0: VersionPartAtom) -> bool: ...
    @property
    def literal(self) -> str: ...
    @property
    def numeral(self) -> int: ...

class VersionPredicate:
    def __init__(self) -> None: ...
    def contains(self, arg0: Version) -> bool: ...
    @staticmethod
    def make_compatible_with(arg0: Version, arg1: int) -> VersionPredicate: ...
    @staticmethod
    def make_equal_to(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_free() -> VersionPredicate: ...
    @staticmethod
    def make_greater(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_greater_equal(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_less(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_less_equal(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_not_equal_to(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_not_starts_with(arg0: Version) -> VersionPredicate: ...
    @staticmethod
    def make_starts_with(arg0: Version) -> VersionPredicate: ...
    def str_conda_build(self) -> str: ...
    def __copy__(self) -> VersionPredicate: ...
    def __deepcopy__(self, memo: dict) -> VersionPredicate: ...
    def __eq__(self, arg0: VersionPredicate) -> bool: ...
    def __ne__(self, arg0: VersionPredicate) -> bool: ...

class VersionSpec:
    all_free_strs: ClassVar[list] = ...  # read-only
    and_token: ClassVar[str] = ...  # read-only
    compatible_str: ClassVar[str] = ...  # read-only
    equal_str: ClassVar[str] = ...  # read-only
    glob_suffix_str: ClassVar[str] = ...  # read-only
    glob_suffix_token: ClassVar[str] = ...  # read-only
    greater_equal_str: ClassVar[str] = ...  # read-only
    greater_str: ClassVar[str] = ...  # read-only
    left_parenthesis_token: ClassVar[str] = ...  # read-only
    less_equal_str: ClassVar[str] = ...  # read-only
    less_str: ClassVar[str] = ...  # read-only
    not_equal_str: ClassVar[str] = ...  # read-only
    or_token: ClassVar[str] = ...  # read-only
    preferred_free_str: ClassVar[str] = ...  # read-only
    right_parenthesis_token: ClassVar[str] = ...  # read-only
    starts_with_str: ClassVar[str] = ...  # read-only
    def __init__(self) -> None: ...
    def contains(self, point: Version) -> bool: ...
    def expression_size(self) -> int: ...
    @staticmethod
    def from_predicate(pred: VersionPredicate) -> VersionSpec: ...
    def is_explicitly_free(self) -> bool: ...
    @staticmethod
    def parse(str: str) -> VersionSpec: ...
    def str_conda_build(self) -> str: ...
    def __copy__(self) -> VersionSpec: ...
    def __deepcopy__(self, memo: dict) -> VersionSpec: ...

def archive_extensions(*args, **kwargs): ...
@overload
def has_archive_extension(arg0: str) -> bool: ...
@overload
def has_archive_extension(arg0: os.PathLike) -> bool: ...
@overload
def strip_archive_extension(arg0: str) -> str: ...
@overload
def strip_archive_extension(arg0: os.PathLike) -> os.PathLike: ...
